좋아—차량 반응(ROS2) 연결을 “바로 따라 하면 되는” 순서로 천천히 진행하자.
(차량 = Jetson/RPi. 이미 client.py가 돌아가고 있다고 가정)

1) ROS2 준비 확인 (30초)
ros2 --version


버전이 찍히면 OK.

안 나오면 우선 ROS2 설치/셋업부터 해야 해. (설치가 안 되어 있으면 알려줘—환경에 맞춰 안내할게)

ROS2 셋업 스크립트 로드:

# 배포에 맞춰 경로가 다를 수 있음 (예: /opt/ros/humble/setup.bash)
source /opt/ros/humble/setup.bash

2) 클라이언트가 ROS2로 퍼블리시하도록 설정

client.py는 옵션으로 /v2x/alert 토픽(std_msgs/String)으로 JSON을 퍼블리시할 수 있어.

클라 env에 ROS2=1 추가:

echo 'ROS2=1' | sudo tee -a /opt/v2x/client.env


클라 서비스 재시작:

sudo systemctl restart v2x-alert-client.service


토픽 확인(ROS2 셋업이 로드된 쉘에서):

ros2 topic list | grep /v2x/alert
# 보이면 OK
ros2 topic echo /v2x/alert
# 서버에서 알림이 오면 JSON 문자열이 보일 거야

3) 간단 “정책 노드” 만들기 (수신→감속/정지)

이 노드는 /v2x/alert(String) 를 구독해서 상황에 따라 /cmd_vel(Twist)로 속도를 낮추거나 정지 명령을 내보내.

파일 만들기:

sudo tee /opt/v2x/alert_policy.py >/dev/null <<'EOF'
#!/usr/bin/env python3
import json, rclpy
from rclpy.node import Node
from std_msgs.msg import String
from geometry_msgs.msg import Twist

class Policy(Node):
    def __init__(self):
        super().__init__('v2x_policy')
        self.sub = self.create_subscription(String, '/v2x/alert', self.cb, 10)
        self.pub = self.create_publisher(Twist, '/cmd_vel', 10)

    def cb(self, msg: String):
        try:
            a = json.loads(msg.data)
            acc = a.get('accident', {})
            d = float(acc.get('distance_m', 1e9))
            typ = acc.get('type', 'unknown')

            cmd = Twist()

            # 데모 정책 (필요에 맞게 수정)
            if typ in ('collision', 'fire') and d <= 500:
                cmd.linear.x = 0.2   # 감속 주행
            if typ in ('blockage',) and d <= 200:
                cmd.linear.x = 0.0   # 정지

            self.pub.publish(cmd)
            self.get_logger().info(f"policy→/cmd_vel: {cmd.linear.x:.2f} (type={typ}, dist={d})")
        except Exception as e:
            self.get_logger().warn(f'bad alert: {e}')

def main():
    rclpy.init()
    node = Policy()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__=='__main__':
    main()
EOF
sudo chmod +x /opt/v2x/alert_policy.py


실행(ROS2 환경 로드된 터미널에서):

source /opt/ros/humble/setup.bash
python3 /opt/v2x/alert_policy.py


확인

다른 터미널에서 수신 확인:

ros2 topic echo /v2x/alert


정책 노드 로그에:

[INFO] policy→/cmd_vel: 0.20 (type=collision, dist=500.0)


같은 메시지가 뜨고,

/cmd_vel 발행 확인:

ros2 topic echo /cmd_vel

4) 실제 이벤트로 동작 확인 (빠른 테스트)

서버에서(이미 만들어둔) 이벤트 발사:

python3 /opt/v2x/emit_event.py --type collision --severity high --distance-m 400 --clip-hint


→ 차량에서 /v2x/alert가 들어오고, 정책 노드가 /cmd_vel을 발행하면 성공.

5) (선택) 정책 노드를 systemd로 자동 실행

systemd는 ROS2 환경을 자동으로 못 불러오니, 래퍼 스크립트로 setup.bash를 소스한 뒤 실행하자.

래퍼 만들기:

sudo tee /opt/v2x/run_policy.sh >/dev/null <<'EOF'
#!/usr/bin/env bash
# ROS2 셋업 경로는 환경에 맞게 수정
source /opt/ros/humble/setup.bash
exec /usr/bin/python3 /opt/v2x/alert_policy.py
EOF
sudo chmod +x /opt/v2x/run_policy.sh


서비스 유닛:

sudo tee /etc/systemd/system/v2x-policy.service >/dev/null <<'EOF'
[Unit]
Description=V2X Policy Node (ROS2)
After=network-online.target
Wants=network-online.target

[Service]
WorkingDirectory=/opt/v2x
ExecStart=/opt/v2x/run_policy.sh
Restart=always
RestartSec=2
# User=jetson   # 필요시 지정

[Install]
WantedBy=multi-user.target
EOF
sudo systemctl daemon-reload
sudo systemctl enable --now v2x-policy.service
journalctl -u v2x-policy.service -f

트러블슈팅 빠른 체크

ros2: command not found → source /opt/ros/humble/setup.bash 먼저 실행

/cmd_vel가 안 보이면:

정책 노드 실행 중인지 ps -ef | grep alert_policy.py

ros2 topic list에 /cmd_vel 있는지

client.env에 ROS2=1 추가했는지, 클라 서비스 재시작 했는지

네임스페이스/토픽명이 프로젝트와 다르면 정책 코드의 토픽명을 맞춰줘

여기까지 되면 “서버가 알림 브로드캐스트 → 차량이 수신 → 정책 노드가 감속/정지 퍼블리시”까지 한 사이클이 완성!
원하면 다음으로 클라이언트 중복 억제 패치나 헬스비트 추가를 이어서 하자.
