네 👍 로그 보면 정상 캡처 성공이에요.

Input #0, video4linux2,v4l2, from '/dev/video0': … yuyv422, 640x480, 30 fps → 장치에서 영상 프레임이 잘 들어옴

Output #0, mp4, to 'test.mp4': … → 인코딩 성공

마지막 줄 video:304kB … kb/s:857.27 → 3초짜리 h264/mp4 파일이 300KB 정도 만들어졌음

중간에 [Dequeued v4l2 buffer contains corrupted data] 경고는 드라이버/버퍼 관련이라 큰 문제는 아니고, 파일 자체는 정상으로 저장됐어요. test.mp4를 열어보면 3초 영상이 잘 재생될 겁니다.

✅ 이제 systemd 서비스도 이 방식으로 고치면 됩니다.
즉, YUYV 입력을 libx264로 인코딩하는 ExecStart:

# /etc/systemd/system/v2x-recorder.service
[Unit]
Description=V2X Circular Recorder (FFmpeg 10s segments)
After=network-online.target

[Service]
Type=simple
ExecStart=/usr/bin/ffmpeg -nostdin -y \
  -f v4l2 -input_format yuyv422 -framerate 30 -video_size 640x480 \
  -i /dev/video0 \
  -c:v libx264 -preset veryfast -crf 23 \
  -f segment -segment_time 10 -reset_timestamps 1 -strftime 1 \
  /var/rec/seg_%s.mp4
Restart=always
RestartSec=2
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target


적용:

sudo systemctl daemon-reload
sudo systemctl restart v2x-recorder.service
journalctl -u v2x-recorder.service -f


정상이라면 /var/rec/seg_<timestamp>.mp4 가 10초마다 계속 생겨야 합니다:

ls -lh /var/rec | tail


👉 제안:

먼저 /var/rec에 세그먼트가 잘 쌓이는지 확인

2~3분 녹화 후 emit_event.py --clip-hint 실행해서 /var/archive/accident_<ts>.mp4 가 생성되는지 확인

원하면 내가 최종적으로 녹화+클립+DB+브로드캐스트까지 모두 돌아가는 end-to-end 테스트 절차를 정리해줄까요?

좋아, 녹화가 잘 굴러가고 있어! 이제 사건 전후 영상 클립 생성을 붙이면 끝이야.
지금은 녹화가 몇 분밖에 안 됐으니, 개발 단계에선 전후 5분(기본값 300초) 대신 짧은 창(예: 60초) 으로 먼저 테스트해보자.

1) 아카이브 폴더 준비
sudo mkdir -p /var/archive
sudo chmod 777 /var/archive     # (개발 중 편의용, 운영에선 755/소유권 조정)

2) make_clip.py에 전후 길이 옵션 추가(개발 모드)

지금 스크립트는 전후 300초 고정이라, 인자 옵션을 추가해 빠르게 테스트할 수 있게 바꾸자.

sudo tee /opt/v2x/make_clip.py >/dev/null <<'EOF'
#!/usr/bin/env python3
import sys, os, time, math, subprocess, argparse

REC_DIR="/var/rec"; OUT_DIR="/var/archive"
os.makedirs(OUT_DIR, exist_ok=True)

def pick_segments(t0, pre, post, segdur=10):
    lo = int(math.floor((t0-pre)/segdur)*segdur)
    hi = int(math.ceil((t0+post)/segdur)*segdur)
    files=[]
    for ts in range(lo, hi, segdur):
        p = f"{REC_DIR}/seg_{ts}.mp4"
        if os.path.exists(p): files.append(p)
    return files

def concat(files, out):
    if not files:
        raise SystemExit("no segment files found for the requested window")
    tmp="/tmp/concat.txt"
    with open(tmp,"w") as f:
        for p in files: f.write(f"file '{p}'\n")
    # copy 실패시 재인코딩으로 fallback
    r = subprocess.run(["ffmpeg","-y","-f","concat","-safe","0","-i",tmp,"-c","copy",out])
    if r.returncode != 0:
        subprocess.check_call(["ffmpeg","-y","-f","concat","-safe","0","-i",tmp,
                               "-c:v","libx264","-crf","23","-preset","veryfast",out])
    print("saved:", out)

if __name__=="__main__":
    ap = argparse.ArgumentParser()
    ap.add_argument("ts", type=float, nargs="?", default=time.time())
    ap.add_argument("--pre", type=int, default=300, help="seconds before ts")
    ap.add_argument("--post", type=int, default=300, help="seconds after ts")
    args = ap.parse_args()

    files = pick_segments(args.ts, args.pre, args.post)
    out = f"{OUT_DIR}/accident_{int(args.ts)}.mp4"
    concat(files, out)
EOF
sudo chmod +x /opt/v2x/make_clip.py

3) 수동으로 짧은 창으로 클립 생성(바로 확인)

현재 시각 기준 전후 60초로 시험:

python3 /opt/v2x/make_clip.py --pre 60 --post 60 $(date +%s)
ls -lh /var/archive | tail


saved: /var/archive/accident_<ts>.mp4 메시지 나오고, 파일이 보이면 성공!

만약 “no segment files found”가 나오면 녹화가 충분히 쌓이지 않은 거야. 1~2분 더 두고 다시 실행해봐.

4) 이벤트→워처까지 E2E로 확인하려면

워처는 make_clip.py에 인자를 안 넘기므로, 기본값(현재 300초)을 씀.
개발 단계에선 기본값을 잠깐 120초로 낮춰 두자(전/후 2분). 위 코드에서 default=300을 default=120으로 바꾸고 저장했으면:

sudo systemctl restart v2x-watcher.service
python3 /opt/v2x/emit_event.py --type collision --severity high --clip-hint
# 잠시 뒤
ls -lh /var/archive | tail


DB 인덱스까지 붙여뒀다면:

python3 /opt/v2x/v2x_db_cli.py --recent 5

5) 흔한 이슈 체크

/var/rec 세그먼트가 충분히 쌓였는지(최소 전/후 합계만큼)

/var/archive 권한/공간

ffmpeg 설치/경로 (which ffmpeg)

파일 확장자: 위 make_clip은 .mp4로 찾음(지금 세그먼트도 .mp4라 OK)

원하면, 워처가 호출할 때 자동으로 짧은 창을 쓰도록(예: --pre 90 --post 90) 변경한 버전도 만들어줄게. 지금은 수동 테스트가 우선이라 이 정도로 바로 확인 가능해!

원인 확정: /var/archive 에 쓸 권한이 없어서 ffmpeg가 출력 파일을 못 열고 실패했어요(“Permission denied”).

해결은 셋 중 하나로 바로 됩니다.

방법 1) /var/archive 권한 부여 (권장)

테스트용으로 현재 사용자에게 쓰기 권한을 주세요.

sudo mkdir -p /var/archive
sudo chown $USER:$USER /var/archive
sudo chmod 775 /var/archive


그 다음 다시:

python3 /opt/v2x/make_clip.py --pre 60 --post 60 $(date +%s)
ls -lh /var/archive | tail

방법 2) 지금만 root로 실행
sudo python3 /opt/v2x/make_clip.py --pre 60 --post 60 $(date +%s)


(운영에선 권한 정리하는 방법 1이 더 깔끔합니다.)

방법 3) 출력 경로를 홈으로 바꾸기

원한다면 스크립트에 --out-dir 옵션을 추가해서 홈 아래로 저장하게 할 수 있어요:

sudo tee /opt/v2x/make_clip.py >/dev/null <<'EOF'
#!/usr/bin/env python3
import sys, os, time, math, subprocess, argparse

REC_DIR="/var/rec"

def pick_segments(t0, pre, post, segdur=10):
    import math
    lo = int(math.floor((t0-pre)/segdur)*segdur)
    hi = int(math.ceil((t0+post)/segdur)*segdur)
    files=[]
    for ts in range(lo, hi, segdur):
        p = f"{REC_DIR}/seg_{ts}.mp4"
        if os.path.exists(p): files.append(p)
    return files

def concat(files, out):
    if not files:
        raise SystemExit("no segment files found for the requested window")
    tmp="/tmp/concat.txt"
    with open(tmp,"w") as f:
        for p in files: f.write(f"file '{p}'\n")
    r = subprocess.run(["ffmpeg","-y","-f","concat","-safe","0","-i",tmp,"-c","copy",out])
    if r.returncode != 0:
        subprocess.check_call(["ffmpeg","-y","-f","concat","-safe","0","-i",tmp,
                               "-c:v","libx264","-crf","23","-preset","veryfast",out])
    print("saved:", out)

if __name__=="__main__":
    ap = argparse.ArgumentParser()
    ap.add_argument("ts", type=float, nargs="?", default=time.time())
    ap.add_argument("--pre", type=int, default=300)
    ap.add_argument("--post", type=int, default=300)
    ap.add_argument("--out-dir", default="/var/archive")
    args = ap.parse_args()

    os.makedirs(args.out_dir, exist_ok=True)
    files = pick_segments(args.ts, args.pre, args.post)
    out = os.path.join(args.out_dir, f"accident_{int(args.ts)}.mp4")
    concat(files, out)
EOF
sudo chmod +x /opt/v2x/make_clip.py


이제:

python3 /opt/v2x/make_clip.py --pre 60 --post 60 --out-dir /home/ubuntu11/archive $(date +%s)
ls -lh /home/ubuntu11/archive | tail

참고 (워처 서비스와 권한)

v2x-watcher.service가 root로 돌아가면 /var/archive에 써도 권한 문제가 없습니다.

반대로 일반 사용자로 워처를 돌리면 /var/archive 권한을 지금처럼 열어줘야 해요.

혼재를 피하려면: “서버의 생성물(아카이브/DB)은 전부 root 또는 전용 유저”로 통일하거나, 경로를 홈 하위로 통일하는 것도 방법입니다.

권한 정리 후 다시 실행해 보면 saved: /var/archive/accident_<ts>.mp4 메시지가 뜰 거예요.
